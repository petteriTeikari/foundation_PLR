# ==============================================================================
# Figure: fig_decomposition_grid
# Description: 5×5 grid showing PLR waveform decomposition across
#              5 decomposition methods × 5 preprocessing categories
#
# IMPORTANT: This script enforces anti-hardcoding rules (CRITICAL-FAILURE-004)
# - NO hardcoded hex colors (use color_defs)
# - NO ggsave() (use save_publication_figure)
# - NO custom theme definitions (use theme_foundation_plr)
# - NO hardcoded dimensions (load from config)
#
# See: .claude/docs/meta-learnings/CRITICAL-FAILURE-004-r-figure-hardcoding.md
# ==============================================================================

# ==============================================================================
# MANDATORY HEADER - DO NOT REMOVE OR MODIFY
# ==============================================================================

# Find project root (required for all paths)
PROJECT_ROOT <- (function() {
  d <- getwd()
  while (d != dirname(d)) {
    if (file.exists(file.path(d, "CLAUDE.md"))) return(d)
    d <- dirname(d)
  }
  stop("Could not find project root (no CLAUDE.md found)")
})()

# Load figure system (MANDATORY)
source(file.path(PROJECT_ROOT, "src/r/figure_system/config_loader.R"))
source(file.path(PROJECT_ROOT, "src/r/figure_system/save_figure.R"))
source(file.path(PROJECT_ROOT, "src/r/theme_foundation_plr.R"))
source(file.path(PROJECT_ROOT, "src/r/color_palettes.R"))

# Load colors from YAML (MANDATORY - no hardcoded colors!)
color_defs <- load_color_definitions()

# ==============================================================================
# END MANDATORY HEADER
# ==============================================================================

# Required packages
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)
library(jsonlite)

# ==============================================================================
# DATA LOADING
# ==============================================================================

# Load data from JSON (generated by Python extraction)
data_path <- file.path(PROJECT_ROOT, "data/r_data/decomposition_grid_data.json")

if (!file.exists(data_path)) {
  stop(paste(
    "Data file not found:", data_path, "\n",
    "Run: uv run python scripts/export_decomposition_data.py"
  ))
}

cat("Loading data from:", data_path, "\n")
raw_data <- fromJSON(data_path)

# ==============================================================================
# DATA TRANSFORMATION
# ==============================================================================

# Method display names
method_names <- c(
  "template" = "Template Fitting",
  "pca" = "Standard PCA",
  "rotated_pca" = "Rotated PCA",
  "sparse_pca" = "Sparse PCA",
  "ged" = "GED"
)

# Category renaming: match other figures' naming convention
category_rename <- c(
  "Ground Truth" = "Ground Truth",
  "Foundation Model" = "Single-model FM",
  "Deep Learning" = "Deep Learning",
  "Traditional" = "Traditional",
  "Ensemble" = "Ensemble FM"
)

# New column order: Ground Truth first (separated), then best to worst
category_order <- c("Ground Truth", "Ensemble FM", "Single-model FM", "Deep Learning", "Traditional")

# Transform nested JSON to long-format data frame
transform_data <- function(raw_data) {
  all_rows <- list()

  for (key in names(raw_data$data)) {
    item <- raw_data$data[[key]]

    time_vec <- item$time_vector
    n_time <- length(time_vec)

    # Add mean waveform
    all_rows[[length(all_rows) + 1]] <- data.frame(
      category = item$category,
      method = item$method,
      time = time_vec,
      component = "Mean",
      mean = item$mean_waveform,
      ci_lower = item$mean_waveform_ci_lower,
      ci_upper = item$mean_waveform_ci_upper,
      stringsAsFactors = FALSE
    )

    # Add components (jsonlite parses as data.frame, not list of lists)
    comps_df <- item$components
    for (i in seq_len(nrow(comps_df))) {
      all_rows[[length(all_rows) + 1]] <- data.frame(
        category = item$category,
        method = item$method,
        time = time_vec,
        component = comps_df$name[i],
        mean = comps_df$mean[[i]],
        ci_lower = comps_df$ci_lower[[i]],
        ci_upper = comps_df$ci_upper[[i]],
        stringsAsFactors = FALSE
      )
    }
  }

  df <- bind_rows(all_rows)

  # Rename categories to match other figures
  df$category <- category_rename[df$category]

  # Set factor levels for ordering
  df$method <- factor(df$method, levels = names(method_names))
  df$category <- factor(df$category, levels = category_order)

  return(df)
}

df <- transform_data(raw_data)
cat("Data transformed:", nrow(df), "rows\n")

# ==============================================================================
# MANUAL Y-AXIS LIMITS (to reduce whitespace)
# ==============================================================================

# Manual y-limits per method (row) - set to reduce whitespace
y_limits_by_method <- data.frame(
  method = factor(names(method_names), levels = names(method_names)),
  y_min = c(-2.87, -0.10, -0.10, -0.10, -0.15),  # template, pca, rotated_pca, sparse_pca, ged
  y_max = c(0.458, 0.10, 0.10, 0.15, 0.15)       # Row 1 auto, others manual
)

cat("Y-limits per method (manual):\n")
print(y_limits_by_method)

# ==============================================================================
# PLOTTING FUNCTION
# ==============================================================================

create_subplot <- function(data_subset, show_legend = FALSE, y_lim = NULL, is_ground_truth = FALSE) {
  # REMOVED: Mean waveform - it clutters the plot and dominates scale
  # Focus only on the decomposed components
  comp_df <- data_subset %>% filter(component != "Mean")

  # Get component colors from config - FIXED ORDER: phasic, sustained, pipr
  # Orange, Sky blue, Bluish green
  color_1 <- color_defs[["--color-decomp-component-1"]]  # Orange - phasic/PC1
  color_2 <- color_defs[["--color-decomp-component-2"]]  # Sky blue - sustained/PC2
  color_3 <- color_defs[["--color-decomp-component-3"]]  # Bluish green - pipr/PC3

  # Map ALL component names to standardized display names
  # This ensures consistent colors across methods
  comp_df <- comp_df %>%
    mutate(
      comp_display = case_when(
        component %in% c("phasic", "PC1", "RC1", "SPC1", "GED1") ~ "phasic",
        component %in% c("sustained", "PC2", "RC2", "SPC2", "GED2") ~ "sustained",
        component %in% c("pipr", "PC3", "RC3", "SPC3", "GED3") ~ "pipr",
        TRUE ~ component
      ),
      # Force order for legend
      comp_display = factor(comp_display, levels = c("phasic", "sustained", "pipr"))
    )

  # Color mapping with standardized names
  comp_color_map <- c(
    "phasic" = color_1,
    "sustained" = color_2,
    "pipr" = color_3
  )

  # Stimulus light colors (from canonical color_palettes.R)
  stimulus_blue <- COLORS_STIMULUS[["blue_480nm"]]

  stimulus_red <- COLORS_STIMULUS[["red_640nm"]]

  # Background color: slightly darker for ground truth to separate it
  bg_color <- if (is_ground_truth) COLORS_PANEL_BG[["ground_truth"]] else COLORS_PANEL_BG[["default"]]

  p <- ggplot() +
    # Stimulus regions - subtle shading
    annotate("rect", xmin = 15.5, xmax = 24.5, ymin = -Inf, ymax = Inf,
             fill = stimulus_blue, alpha = 0.06) +
    annotate("rect", xmin = 46.5, xmax = 55.5, ymin = -Inf, ymax = Inf,
             fill = stimulus_red, alpha = 0.06) +
    # Components with CIs (using standardized comp_display)
    geom_ribbon(data = comp_df,
                aes(x = time, ymin = ci_lower, ymax = ci_upper,
                    fill = comp_display, group = component),
                alpha = 0.25) +
    geom_line(data = comp_df,
              aes(x = time, y = mean, color = comp_display, group = component),
              linewidth = 1.0) +
    # Scales with EXPLICIT ordering: phasic -> sustained -> pipr
    scale_color_manual(
      values = comp_color_map,
      breaks = c("phasic", "sustained", "pipr"),
      labels = c("phasic", "sustained", "pipr")
    ) +
    scale_fill_manual(
      values = comp_color_map,
      breaks = c("phasic", "sustained", "pipr"),
      labels = c("phasic", "sustained", "pipr")
    ) +
    scale_x_continuous(breaks = c(0, 20, 40, 60))

  # Apply row-wise y-axis limits if provided
  # Use consistent label formatting to ensure alignment across rows
  if (!is.null(y_lim)) {
    p <- p + scale_y_continuous(
      limits = y_lim,
      labels = function(x) sprintf("%5.2f", x)  # Fixed width format
    )
  }

  p <- p +
    # Force vertical legend with explicit guide
    guides(
      color = guide_legend(
        title = NULL,  # Remove title to save space
        direction = "vertical",
        ncol = 1,
        override.aes = list(linewidth = 2)  # Thicker lines in legend
      ),
      fill = guide_legend(
        title = NULL,
        direction = "vertical",
        ncol = 1
      )
    ) +
    # Theme
    theme_foundation_plr() +
    theme(
      # VERTICAL LEGEND
      legend.position = if (show_legend) "right" else "none",
      legend.direction = "vertical",
      legend.title = element_blank(),
      legend.text = element_text(size = 9),
      legend.key.size = unit(0.5, "cm"),
      legend.key.height = unit(0.6, "cm"),
      legend.background = element_rect(fill = color_defs[["--color-white"]], color = color_defs[["--color-grid"]], linewidth = 0.3),
      legend.margin = margin(4, 6, 4, 4),
      legend.spacing.y = unit(0.3, "cm"),
      axis.title = element_blank(),
      # SMALLER tick labels than column titles (which are size 9)
      axis.text = element_text(size = 7),
      axis.text.x = element_text(size = 7),
      axis.text.y = element_text(size = 7),
      plot.margin = margin(2, 2, 2, 2),
      # Background color for ground truth separation
      panel.background = element_rect(fill = bg_color, color = NA),
      plot.background = element_rect(fill = bg_color, color = NA)
    )

  return(p)
}

# ==============================================================================
# CREATE 5×5 GRID
# ==============================================================================

cat("Creating 5×5 grid...\n")

# Row order: template, pca, rotated_pca, sparse_pca, ged
# Column order: Ground Truth, Ensemble FM, Single-model FM, Deep Learning, Traditional
methods_ordered <- names(method_names)
categories_ordered <- category_order  # Use new order: GT first, then best to worst

# Create all subplots with row-wise y-limits
plots <- list()

for (method in methods_ordered) {
  # Get y-limits for this method (row)
  method_limits <- y_limits_by_method %>% filter(method == !!method)
  y_lim <- c(method_limits$y_min, method_limits$y_max)

  for (category in categories_ordered) {
    data_subset <- df %>% filter(method == !!method, category == !!category)

    # Show legend only for top-right subplot (Traditional is now last column)
    show_legend <- (method == "template" && category == "Traditional")

    # Check if this is ground truth column (for darker background)
    is_gt <- (category == "Ground Truth")

    plots[[paste(method, category, sep = "__")]] <- create_subplot(
      data_subset,
      show_legend = show_legend,
      y_lim = y_lim,
      is_ground_truth = is_gt
    )
  }
}

# Create row plots
row_plots <- list()
for (i_row in seq_along(methods_ordered)) {
  method <- methods_ordered[i_row]
  row <- list()
  for (i_col in seq_along(categories_ordered)) {
    category <- categories_ordered[i_col]
    key <- paste(method, category, sep = "__")
    p <- plots[[key]]

    # Add column labels to top row
    if (i_row == 1) {
      p <- p + ggtitle(category) + theme(plot.title = element_text(size = 9, face = "bold", hjust = 0.5))
    }

    # Add row labels to left column - method name + normalized unit
    if (i_col == 1) {
      # Use method name as y-axis title (serves as row label)
      # Add "Normalized Unit" below in smaller text
      p <- p + ylab(paste0(method_names[method], "\n(Normalized Unit)")) +
        theme(axis.title.y = element_text(size = 7, face = "bold", angle = 90, vjust = 0.5,
                                          lineheight = 0.9))
    }

    # Add x-axis label to bottom row
    if (i_row == length(methods_ordered)) {
      p <- p + xlab("Time [s]") +
        theme(axis.title.x = element_text(size = 8))
    }

    row[[i_col]] <- p
  }
  row_plots[[i_row]] <- wrap_plots(row, ncol = 5)
}

# Combine all rows
combined <- wrap_plots(row_plots, ncol = 1) +
  plot_annotation(
    title = "PLR Waveform Decomposition by Preprocessing Method",
    theme = theme(plot.title = element_text(size = 12, face = "bold", hjust = 0.5))
  )

# ==============================================================================
# SAVE FIGURE
# ==============================================================================

cat("Saving figure...\n")

# Save using figure system (routes to supplementary automatically)
save_publication_figure(combined, "fig_decomposition_grid",
                        width = 14, height = 10)

cat("✅ Figure generated successfully\n")
